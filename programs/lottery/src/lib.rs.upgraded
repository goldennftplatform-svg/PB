// UPGRADED VERSION - Fixes deterministic winner selection
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount};
use solana_program::clock::Clock;

declare_id!("Ayf1yysvTa1KPVC3ZDwMJ5nScGcsxJnfXSRpP8BvCBWX");

#[program]
pub mod lottery {
    use super::*;

    // ... (keep initialize_lottery and enter functions the same) ...

    pub fn take_snapshot(ctx: Context<TakeSnapshot>) -> Result<()> {
        let lottery = &mut ctx.accounts.lottery;
        let clock = Clock::get()?;
        
        require!(lottery.is_active, ErrorCode::LotteryInactive);
        
        // Dynamic timing based on fees collected
        let snapshot_interval = if lottery.fees_collected >= lottery.fast_mode_threshold {
            lottery.fast_snapshot_interval // 48 hours for 200+ SOL fees
        } else {
            lottery.base_snapshot_interval  // 72 hours for < 200 SOL fees
        };
        
        require!(
            clock.unix_timestamp - lottery.last_snapshot >= snapshot_interval as i64,
            ErrorCode::DrawTooEarly
        );
        
        require!(lottery.participants.len() >= 6, ErrorCode::NotEnoughParticipants);
        
        // UPGRADE: Improved randomness using clock data
        let seed = clock.slot
            .wrapping_mul(clock.unix_timestamp as u64)
            .wrapping_add(lottery.participants.len() as u64)
            .wrapping_add(lottery.total_snapshots);
        
        // UPGRADE: Weighted random selection based on ticket count
        let total_tickets: u32 = lottery.participants.iter()
            .map(|p| p.ticket_count)
            .sum();
        
        if total_tickets == 0 {
            return Err(ErrorCode::NotEnoughParticipants.into());
        }
        
        // Select main winner (weighted by tickets)
        let main_winner_ticket = (seed % total_tickets as u64) as u32;
        let mut accumulated = 0u32;
        let mut main_winner_idx = 0;
        
        for (idx, participant) in lottery.participants.iter().enumerate() {
            accumulated += participant.ticket_count;
            if accumulated > main_winner_ticket {
                main_winner_idx = idx;
                break;
            }
        }
        
        lottery.winners.main_winner = Some(lottery.participants[main_winner_idx].wallet);
        
        // Select 5 minor winners (excluding main winner)
        let mut minor_indices = Vec::new();
        let mut remaining_seed = seed.wrapping_mul(7); // Different seed
        
        for _ in 0..5 {
            let available: Vec<usize> = (0..lottery.participants.len())
                .filter(|&i| i != main_winner_idx && !minor_indices.contains(&i))
                .collect();
            
            if available.is_empty() {
                break;
            }
            
            let winner_idx = available[(remaining_seed as usize) % available.len()];
            minor_indices.push(winner_idx);
            remaining_seed = remaining_seed.wrapping_mul(13).wrapping_add(1);
        }
        
        let mut minor_winners = Vec::with_capacity(5);
        for idx in minor_indices {
            minor_winners.push(lottery.participants[idx].wallet);
        }
        lottery.winners.minor_winners = minor_winners;
        
        lottery.last_snapshot = clock.unix_timestamp;
        lottery.total_snapshots += 1;
        
        // Update fast mode status
        lottery.is_fast_mode = lottery.fees_collected >= lottery.fast_mode_threshold;
        
        // Log the snapshot
        let timing = if lottery.is_fast_mode {
            "48-hour"
        } else {
            "72-hour"
        };
        
        msg!("ðŸ“¸ SNAPSHOT TAKEN! ðŸ“¸");
        msg!("Jackpot: {} SOL", lottery.jackpot_amount / 1_000_000_000);
        msg!("Fees Collected: {} SOL", lottery.fees_collected / 1_000_000_000);
        msg!("Timing: {} snapshots", timing);
        msg!("Main Winner: {}", lottery.winners.main_winner.unwrap());
        msg!("Minor Winners: {}", lottery.winners.minor_winners.len());
        
        lottery.participants.clear();
        
        Ok(())
    }

    pub fn payout_winners(ctx: Context<PayoutWinners>) -> Result<()> {
        let lottery = &mut ctx.accounts.lottery;
        require!(lottery.winners.main_winner.is_some(), ErrorCode::NoWinners);
        
        // Calculate payouts
        let total_jackpot = lottery.jackpot_amount;
        let main_payout = (total_jackpot * 60) / 100; // 60% to main winner
        let minor_payout_per_winner = (total_jackpot * 40) / 100 / 5; // 40% split among 5 minor winners
        
        msg!("ðŸ’° PAYOUT DISTRIBUTION ðŸ’°");
        msg!("Total Jackpot: {} SOL", total_jackpot / 1_000_000_000);
        msg!("Main Winner: {} SOL (60%)", main_payout / 1_000_000_000);
        msg!("Each Minor Winner: {} SOL (8%)", minor_payout_per_winner / 1_000_000_000);
        
        // UPGRADE: Real SOL transfers (requires account structure update)
        // Transfer SOL to main winner
        **ctx.accounts.main_winner.lamports.borrow_mut() += main_payout;
        **ctx.accounts.lottery.to_account_info().lamports.borrow_mut() -= main_payout;
        
        // Transfer SOL to minor winners
        for minor_winner in &ctx.accounts.minor_winners {
            **minor_winner.lamports.borrow_mut() += minor_payout_per_winner;
            **ctx.accounts.lottery.to_account_info().lamports.borrow_mut() -= minor_payout_per_winner;
        }
        
        lottery.winners.main_winner = None;
        lottery.winners.minor_winners.clear();
        
        Ok(())
    }

    // ... (rest of functions remain the same) ...
}

// Note: PayoutWinners accounts structure would need to be updated to include:
// - main_winner: AccountInfo<'info> (mut)
// - minor_winners: Vec<AccountInfo<'info>> (mut)
// - lottery: Account<'info, Lottery> (mut)



